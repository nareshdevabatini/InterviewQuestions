Along with component, Angular 2.0 has also have two other kind of directives such  as  Structural directives and Attribute Directive.
Directives are used to change the behavior as well as layout of the DOM elements.  It is possible that the same DOM element may have a
number of directives. However, in case of component it is not possible, any DOM element can have only a single component.

Lets create a progress bar directive as following:

<div class="progress">
  <div [progressbar] ='60' class="progress-bar" role="progressbar" [contextType]='2'
       aria-valuemin="0" aria-valuemax="100">
    
  </div>
</div>

Therefore, there are two input progressbar and contextType; progressbar will determine the width of the progressbar and contextType
will determine the class type.
=> If  contextType =1 , then class = .progress-bar-success
=> If  contextType =2 , then class =.progress-bar-info
=> If  contextType =3 , then class = .progress-bar-warning
=> Otherwise, class = .progress-bar-danger

Here in the example, [progressbar] =’60’ and [contextType]=’2′

Create a class called Progerssbar



import { Directive, ElementRef, Input,Renderer,OnInit,HostListener, } from '@angular/core';
@Directive({ selector: '[progressbar]' })
export class ProgressBarDirective  implements OnInit {
  private className:string;

  @Input('progressbar') progressValue: string;

  @Input('contextType') contextType: string;

  constructor(private el: ElementRef,private renderer: Renderer) {
  }

  ngOnInit() {

    this.el.nativeElement.style.width=this.progressValue+'%';

    if(this.contextType ==='1' )
      this.className = 'progress-bar-success';
    else if (this.contextType ==='2')
      this.className = 'progress-bar-info';
    else if (this.contextType ==='3')
      this.className = 'progress-bar-warning';
    else
      this.className = 'progress-bar-danger';

    this.renderer.setElementClass(this.el.nativeElement, this.className, true);
  }
  @HostListener('mouseenter') onMouseEnter() {
    this.el.nativeElement.title=this.progressValue;
  }

}

import { Directive, ElementRef, Input,Renderer,OnInit,HostListener, } from '@angular/core';
@Directive({ selector: '[progressbar]' })
export class ProgressBarDirective  implements OnInit {
  private className:string;
 
  @Input('progressbar') progressValue: string;
 
  @Input('contextType') contextType: string;
 
  constructor(private el: ElementRef,private renderer: Renderer) {
  }
 
  ngOnInit() {
 
    this.el.nativeElement.style.width=this.progressValue+'%';
 
    if(this.contextType ==='1' )
      this.className = 'progress-bar-success';
    else if (this.contextType ==='2')
      this.className = 'progress-bar-info';
    else if (this.contextType ==='3')
      this.className = 'progress-bar-warning';
    else
      this.className = 'progress-bar-danger';
 
    this.renderer.setElementClass(this.el.nativeElement, this.className, true);
  }
  @HostListener('mouseenter') onMouseEnter() {
    this.el.nativeElement.title=this.progressValue;
  }
 
}

Mention the selector for the directive.


@Directive({ selector: '[progressbar]' })

@Directive({ selector: '[progressbar]' })
In order to change the behavior of the DOM element, it needs to be declared


constructor(private el: ElementRef,private renderer: Renderer) {
  }

constructor(private el: ElementRef,private renderer: Renderer) {
  }
In order to change the class for the element, the Rendered is also need to be declared


constructor(private el: ElementRef,private renderer: Renderer) {
  }

constructor(private el: ElementRef,private renderer: Renderer) {
  }
Now based on the  input progressbar , we have to change the width of the nativeelement


this.el.nativeElement.style.width=this.progressValue+'%';

this.el.nativeElement.style.width=this.progressValue+'%';
Next requirement is to change the class


this.renderer.setElementClass(this.el.nativeElement, this.className, true);

this.renderer.setElementClass(this.el.nativeElement, this.className, true);
Directive can also be used for event handling. As for example, here @HostListening is kept listening for a ‘mouseenter’ 
event and as soon as there is a ‘mouseenter’ event trigger, it perform respective change in behaviour.
